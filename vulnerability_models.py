"""
ENEO Asteroid Impact Simulation - Vulnerability Models Module

This module contains mathematical models for calculating human population vulnerability
to various asteroid impact effects. Each vulnerability function returns a value between
0.0 (no vulnerability) and 1.0 (complete vulnerability/fatality) for a given impact parameter.

The vulnerability models are based on peer-reviewed research by C. Rumpf and colleagues,
incorporating data from various sources including Glasstone 1977, Wu2015, NOAA, and the
American Burn Association.

Author: Alexandros Notas
Based on research by: C. M. Rumpf, H. G. Lewis, and P. M. Atkinson
Reference: "Population Vulnerability Models for Asteroid Impact Risk Assessment," 
           Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
"""

import numpy as N  # Using N alias for numpy to maintain consistency with original implementation
import math # Retaining math for now, in case other parts of the file (not shown) use it. Can be removed if N replaces all math usage.

# =============================================================================
# VULNERABILITY MODELS
# =============================================================================
def fun_CraterVulnerability(dist_m, final_crater_diam, pixel_len):
    """
    Calculates population vulnerability to direct crater formation from asteroid impact.
    
    This function determines the probability of fatality due to being within or near
    the impact crater. It accounts for partial coverage of grid cells and provides
    proportional vulnerability for cells that are only partially affected by the crater.
    
    Parameters
    ----------
    dist_m : float
        Distance from impact point in meters
    final_crater_diam : float
        Diameter of the final crater in meters (after rim collapse and stabilization)
    pixel_len : float
        Resolution of the population grid in meters per pixel (typically ~4600m for global grids)
    
    Returns
    -------
    vuln_crater : float
        Vulnerability to crater formation (0.0 = no risk, 1.0 = complete fatality)
        
    Algorithm Details
    -----------------
    The function uses geometric calculations to determine what fraction of a population
    grid cell is covered by the crater. For cells completely within the crater,
    vulnerability is 1.0. For partially covered cells, vulnerability is proportional
    to the coverage fraction.
    
    Mathematical Approach:
    1. Convert distance to pixel units for grid-based calculations
    2. Calculate crater area and affected pixel ring area
    3. Determine intersection geometry between crater circle and pixel grid
    4. Apply proportional vulnerability based on coverage ratio
        
    References
    ----------
    Derived and implemented by C. Rumpf
    Further description in C. M. Rumpf, H. G. Lewis, and P. M. Atkinson, 
    "Population Vulnerability Models for Asteroid Impact Risk Assessment," 
    Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
    """
    
    # Calculate crater radius for geometric calculations
    crater_radius = final_crater_diam / 2.0
    
    # Convert distance to pixel units (rounded to nearest integer for grid alignment)
    dist_pix = round(dist_m / pixel_len)
    
    # Calculate areas for geometric intersection analysis
    cell_area = pixel_len * pixel_len #m^2 = 4.6km x 4.6km (typical global grid resolution)
    crater_area = N.pi * ((final_crater_diam / 2.0)**2.0)  # Circular crater area
    
    # Calculate the area of the pixel ring at the given distance
    # Uses (2*dist_pix+1)^2 to account for the full ring of pixels at distance dist_pix
    pix_area = ((2.0*dist_pix+1.0)**2.0) * cell_area
    
    # Ratio of crater area to the pixel ring area (for proportional vulnerability)
    crater2cell_ratio = crater_area / pix_area
    
    # Check if we have a valid crater and are within the affected region
    if (final_crater_diam > 0.0) and dist_m <= (crater_radius + (pixel_len/2.0)): # we have a crater and are in affected region
        
        # Case 1: Crater is contained within a single pixel
        if (dist_pix < 1.0) and (crater2cell_ratio <= 1.0): # crater only within one pixel
            vuln_crater = crater2cell_ratio  # Vulnerability proportional to crater coverage
        else: # pixel dist is at least one
            # Case 2: Multi-pixel crater requiring ring-based calculation
            
            # Calculate area inside the pixel ring using Pythagorean distance approximation
            inside_pix_area = ((dist_pix**2)/2.0) * cell_area   # pythagoras dist_m^2=dist_pix^2+dist_pix^2
            
            # Calculate the intersection of crater circle with the pixel ring
            area_circle_secs = N.abs(crater_area-inside_pix_area)  # Crater area in the ring
            area_pix_ring = pix_area - inside_pix_area  # Total ring area available
            
            # Vulnerability is the fraction of the ring covered by the crater
            vuln_crater = area_circle_secs / area_pix_ring
            
            # Ensure vulnerability doesn't exceed maximum (complete fatality)
            if vuln_crater > 1.0:
                vuln_crater = 1.0
            
    else: # area is not affected by crater
        vuln_crater = 0.0  # No crater effect at this distance
    return vuln_crater

def fun_SeismicVulnerability(eff_mag):
    """
    Parameters
    ----------
    eff_mag : float
        seismic shock Richter scale value
    
    Returns
    -------
    vuln_seis : float
        vulnerability to seismic shock
        
    Description
    -----------
    Calculates the vulnerability to seismic shock based on data in Wu2015.
    Derived and implemented by C. Rumpf
    Further description in C. M. Rumpf, H. G. Lewis, and P. M. Atkinson, “Population Vulnerability Models for Asteroid Impact Risk Assessment,” Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
    """

    vuln_seis = 1. / (1. + N.exp(-2.51607678 * (eff_mag - 8.68559246)))
    if vuln_seis > 1.0:
         vuln_seis = 1.0
    elif vuln_seis < 0.0 or eff_mag < 4.5:
         vuln_seis = 0.0
        
    return vuln_seis
    
def fun_OverpressureVulnerability(press):
    """
    Parameters
    ----------
    press : float
        Air blast shockwave overpressure (Pascal)
    
    Returns
    -------
    vuln_press : float
        vulnerability to overpressure
        
    Description
    -----------
    Calculates the expected vulnerability to overpressure based on Glasstone 
    1977. A sigmoid function has been fitted to the data.
    Derived and implemented by C. Rumpf
    Further description in C. M. Rumpf, H. G. Lewis, and P. M. Atkinson, “Population Vulnerability Models for Asteroid Impact Risk Assessment,” Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
    """
    if press <= 150000.0:
        vuln_press = 0.0
    elif press >= 900000.0:
        vuln_press = 1.0
    else:
         vuln_press = 1. / (1. + N.exp(-(press-440430.986)*0.0000242498102))
         #vuln_press = -2.45179368e-12 * press**2.0 + 5.02058480e-06 * press -1.19814335 old model
         if vuln_press > 1.0:
             vuln_press = 1.0
         elif vuln_press < 0.0:
             vuln_press = 0.0
         
    return vuln_press
    
def fun_ThermRadVulnerability(phi):
    """
    Parameters
    ----------
    phi : float
        Thermal Energy Density in (J/m^2)
    
    Returns
    -------
    vuln_therm : float
        vulnerability to thermal radiation energy
        
    Description
    -----------
    Calculates the vulnerability to thermal radiation energy (Glasstone, American Burn Association).
    Derived and implemented by C. Rumpf
    Further description in C. M. Rumpf, H. G. Lewis, and P. M. Atkinson, "Population Vulnerability Models for Asteroid Impact Risk Assessment," Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
    """
    vuln_therm = 0.47 * ( 1. / (1. + N.exp( -0.00000562326741 * ( phi - 731641.664 ))))
    if phi < 85000.0 or vuln_therm < 0.0:
        vuln_therm = 0.0
    elif vuln_therm > 1.0:
        vuln_therm = 1.0
        
    return vuln_therm
    
def fun_HighWindVulnerability(v_wind):
    """
    Parameters
    ----------
    v_wind : float
        Wind speed in (m/s)
    
    Returns
    -------
    vuln_wind : float
        vulnerability to high winds
        
    Description
    -----------
    Calculates the vulnerability to high winds (Glasstone, NOAA) in the
    expected scenario.
    Derived and implemented by C. Rumpf
    Further description in C. M. Rumpf, H. G. Lewis, and P. M. Atkinson, “Population Vulnerability Models for Asteroid Impact Risk Assessment,” Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
    """

    vuln_wind = 1. / (1. + N.exp(-(v_wind-1.12444654e+02)*5.48261521e-02))

    if v_wind < 10. or vuln_wind < 0.0:
        vuln_wind = 0.0
    elif vuln_wind > 1.0 or v_wind > 250.:
        vuln_wind = 1.0
        
    return vuln_wind
    
def fun_EjectaBlanketVulnerability(t_ejecta):
    """
    Parameters
    ----------
    t_ejecta : float
        Ejecta Blanket thickness (m)
    
    Returns
    -------
    vuln_ejecta : float
        vulnerability to ejecta blanket thickness
        
    Description
    -----------
    Calculates the vulnerability to building collapse due to ejecta blanket 
    loading in the expected case.
    Derived and implemented by C. Rumpf
    Further description in C. M. Rumpf, H. G. Lewis, and P. M. Atkinson, “Population Vulnerability Models for Asteroid Impact Risk Assessment,” Meteorit. Planet. Sci., vol. 52, no. 6, pp. 1082–1102, 2017.
    """
    ejecta_load_kPa = t_ejecta * 1.6 * 9.80655 # thickness * density[t/m3] * g_0
    P_collapse = (1.0 + N.exp(-1.37*(ejecta_load_kPa-3.14)))**(-4.6)    
    vuln_ejecta = 0.078 * P_collapse

    if vuln_ejecta < 0.0 or t_ejecta < 0.001:
        vuln_ejecta = 0.0
    elif vuln_ejecta > 1.0:
        vuln_ejecta = 1.0
        
    return vuln_ejecta